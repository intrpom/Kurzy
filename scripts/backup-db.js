#!/usr/bin/env node

// Skript pro z√°lohov√°n√≠ datab√°ze lok√°lnƒõ
// Pou≈æit√≠: node scripts/backup-to-github.js
const { PrismaClient } = require('@prisma/client');
const fs = require('fs');
const path = require('path');

const dotenv = require('dotenv');

// Naƒçten√≠ promƒõnn√Ωch prost≈ôed√≠ z .env souboru
dotenv.config({ path: path.join(__dirname, '../.env') });

// Kontrola, zda je nastavena promƒõnn√° DATABASE_URL
if (!process.env.DATABASE_URL && !process.env.PRISMA_DATABASE_URL) {
  console.error('Chyba: Nen√≠ nastavena ≈æ√°dn√° datab√°zov√° URL');
  process.exit(1);
}

// Vytvo≈ôen√≠ instance Prisma klienta
const prisma = new PrismaClient();

/**
 * Pokroƒçil√° kontrola integrity z√°lohy - ovƒõ≈ô√≠ velikosti soubor≈Ø, konzistenci dat a porovn√° s p≈ôedchoz√≠mi z√°lohami
 */
async function performBackupIntegrityCheck(backupDir, originalData) {
  try {
    console.log('   üîç Kontroluji velikosti soubor≈Ø...');
    
    const backupFiles = [
      { name: 'courses.json', data: originalData.courses, minSize: 1000 },
      { name: 'users.json', data: originalData.users, minSize: 200 },
      { name: 'user-courses.json', data: originalData.userCourses, minSize: 50 },
      { name: 'blog-posts.json', data: originalData.blogPosts, minSize: 1000 },
      { name: 'auth-tokens.json', data: originalData.authTokens, minSize: 10 },
      { name: 'user-lesson-progress.json', data: originalData.userLessonProgress, minSize: 50 },
      { name: 'user-mini-courses.json', data: originalData.userMiniCourses, minSize: 10 },
      { name: 'testtable.json', data: originalData.testtableData, minSize: 2 }, // minim√°lnƒõ []
      { name: 'metadata.json', data: null, minSize: 100 }
    ];
    
    let totalBackupSize = 0;
    let filesChecked = 0;
    let warnings = [];
    
    for (const file of backupFiles) {
      const filePath = path.join(backupDir, file.name);
      
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        const fileSizeKB = Math.round(stats.size / 1024 * 100) / 100;
        totalBackupSize += stats.size;
        filesChecked++;
        
        // Kontrola minim√°ln√≠ velikosti
        if (stats.size < file.minSize) {
          warnings.push(`‚ö†Ô∏è  ${file.name}: Podez≈ôele mal√Ω soubor (${fileSizeKB} KB)`);
        }
        
        // Kontrola konzistence dat vs soubor
        if (file.data && Array.isArray(file.data)) {
          const fileContent = JSON.parse(fs.readFileSync(filePath, 'utf8'));
          if (fileContent.length !== file.data.length) {
            warnings.push(`‚ùå ${file.name}: Nesouhlas√≠ poƒçet z√°znam≈Ø (soubor: ${fileContent.length}, data: ${file.data.length})`);
          } else {
            console.log(`   ‚úÖ ${file.name}: ${fileContent.length} z√°znam≈Ø, ${fileSizeKB} KB`);
          }
        } else {
          console.log(`   ‚úÖ ${file.name}: ${fileSizeKB} KB`);
        }
      } else {
        warnings.push(`‚ùå Chyb√≠ soubor: ${file.name}`);
      }
    }
    
    console.log(`\n   üìä Celkov√° velikost z√°lohy: ${Math.round(totalBackupSize / 1024)} KB`);
    console.log(`   üìÅ Zkontrolov√°no soubor≈Ø: ${filesChecked}/${backupFiles.length}`);
    
    // Kontrola JSON validity
    console.log('\n   üîç Kontroluji validitu JSON soubor≈Ø...');
    let validJsonFiles = 0;
    for (const file of backupFiles) {
      const filePath = path.join(backupDir, file.name);
      if (fs.existsSync(filePath)) {
        try {
          JSON.parse(fs.readFileSync(filePath, 'utf8'));
          validJsonFiles++;
        } catch (error) {
          warnings.push(`‚ùå ${file.name}: Neplatn√Ω JSON - ${error.message}`);
        }
      }
    }
    console.log(`   ‚úÖ Validn√≠ch JSON soubor≈Ø: ${validJsonFiles}/${filesChecked}`);
    
    // Porovn√°n√≠ s p≈ôedchoz√≠ z√°lohou
    console.log('\n   üîç Porovn√°v√°m s p≈ôedchoz√≠ z√°lohou...');
    await compareWithPreviousBackup(backupDir, originalData);
    
    // V√Ωsledek kontroly
    if (warnings.length === 0) {
      console.log('\n   ‚úÖ Integrita z√°lohy: PERFEKTN√ç');
      console.log('   üõ°Ô∏è  V≈°echny kontroly pro≈°ly √∫spƒõ≈°nƒõ');
    } else {
      console.log('\n   ‚ö†Ô∏è  Nalezena upozornƒõn√≠:');
      warnings.forEach(warning => console.log(`      ${warning}`));
      
      if (warnings.some(w => w.includes('‚ùå'))) {
        console.log('\n   üö® KRITICK√â CHYBY - zkontroluj z√°lohu!');
      } else {
        console.log('\n   üí° Pouze upozornƒõn√≠ - z√°loha je pravdƒõpodobnƒõ v po≈ô√°dku');
      }
    }
    
  } catch (error) {
    console.error('   ‚ùå Chyba p≈ôi kontrole integrity:', error.message);
    console.log('   ‚ö†Ô∏è  Pokraƒçujem bez kontroly integrity...');
  }
}

/**
 * Porovn√°n√≠ s p≈ôedchoz√≠ z√°lohou pro detekci neoƒçek√°van√Ωch zmƒõn
 */
async function compareWithPreviousBackup(currentBackupDir, currentData) {
  try {
    const backupDir = path.dirname(currentBackupDir);
    const backups = fs.readdirSync(backupDir)
      .filter(dir => dir.startsWith('backup-') && dir !== path.basename(currentBackupDir))
      .sort()
      .reverse(); // nejnovƒõj≈°√≠ prvn√≠
    
    if (backups.length === 0) {
      console.log('   ‚ÑπÔ∏è  ≈Ω√°dn√° p≈ôedchoz√≠ z√°loha k porovn√°n√≠');
      return;
    }
    
    const previousBackupDir = path.join(backupDir, backups[0]);
    const previousMetadataPath = path.join(previousBackupDir, 'metadata.json');
    
    if (!fs.existsSync(previousMetadataPath)) {
      console.log('   ‚ö†Ô∏è  P≈ôedchoz√≠ z√°loha nem√° metadata');
      return;
    }
    
    const previousMetadata = JSON.parse(fs.readFileSync(previousMetadataPath, 'utf8'));
    const currentStats = {
      courses: currentData.courses.length,
      users: currentData.users.length,
      blogPosts: currentData.blogPosts.length,
      userCourses: currentData.userCourses.length,
      userMiniCourses: currentData.userMiniCourses.length,
      userLessonProgress: currentData.userLessonProgress.length,
      authTokens: currentData.authTokens.length,
      testtable: currentData.testtableData.length
    };
    
    console.log(`   üìÖ Porovn√°v√°m s: ${backups[0]}`);
    
    let significantChanges = [];
    let normalChanges = [];
    
    for (const [key, currentValue] of Object.entries(currentStats)) {
      const previousValue = previousMetadata.stats[key] || 0;
      const diff = currentValue - previousValue;
      
      if (diff !== 0) {
        const changeText = `${key}: ${previousValue} ‚Üí ${currentValue} (${diff > 0 ? '+' : ''}${diff})`;
        
        // Detekce v√Ωznamn√Ωch zmƒõn
        if (key === 'courses' && Math.abs(diff) > 0) {
          significantChanges.push(`üìö ${changeText}`);
        } else if (key === 'users' && diff > 5) {
          significantChanges.push(`üë• ${changeText}`);
        } else if (key === 'blogPosts' && Math.abs(diff) > 0) {
          significantChanges.push(`üìù ${changeText}`);
        } else if (key === 'userMiniCourses' && Math.abs(diff) > 0) {
          significantChanges.push(`üõí ${changeText}`);
        } else {
          normalChanges.push(`   ${changeText}`);
        }
      }
    }
    
    if (significantChanges.length > 0) {
      console.log('   üìà V√Ωznamn√© zmƒõny:');
      significantChanges.forEach(change => console.log(`      ${change}`));
    }
    
    if (normalChanges.length > 0) {
      console.log('   üìä Bƒõ≈æn√© zmƒõny:');
      normalChanges.forEach(change => console.log(`      ${change}`));
    }
    
    if (significantChanges.length === 0 && normalChanges.length === 0) {
      console.log('   ‚úÖ ≈Ω√°dn√© zmƒõny od posledn√≠ z√°lohy');
    }
    
  } catch (error) {
    console.log('   ‚ö†Ô∏è  Nelze porovnat s p≈ôedchoz√≠ z√°lohou:', error.message);
  }
}

/**
 * Kontrola kompletnosti z√°lohov√°n√≠ - ovƒõ≈ô√≠, ≈æe se z√°lohuj√≠ v≈°echny tabulky
 */
async function checkBackupCompleteness() {
  try {
    // Seznam tabulek, kter√© se aktu√°lnƒõ z√°lohuj√≠
    const backedUpTables = [
      'User',
      'Course',
      'Module',    // z√°lohuje se vno≈ôenƒõ v Course
      'Lesson',    // z√°lohuje se vno≈ôenƒõ v Course -> Module
      'Material',  // z√°lohuje se vno≈ôenƒõ v Course -> Module -> Lesson
      'BlogPost',
      'UserCourse',
      'UserLessonProgress',
      'UserMiniCourse',
      'AuthToken',
      'Testtable'  // v≈°echny tabulky pro jistotu
    ];
    
    // Z√≠sk√°n√≠ v≈°ech tabulek z datab√°ze pomoc√≠ raw SQL
    const tables = await prisma.$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_type = 'BASE TABLE'
      AND table_name NOT LIKE '_prisma%'
      ORDER BY table_name;
    `;
    
    const dbTableNames = tables.map(t => {
      // P≈ôevod z snake_case na PascalCase (nap≈ô. user_courses -> UserCourse)
      const tableName = t.table_name.toLowerCase();
      
      // Speci√°ln√≠ mapov√°n√≠ pro zn√°m√© tabulky
      const tableMapping = {
        'user': 'User',
        'course': 'Course',
        'module': 'Module',
        'lesson': 'Lesson',
        'material': 'Material',
        'blogpost': 'BlogPost',
        'usercourse': 'UserCourse',
        'userlessonprogress': 'UserLessonProgress',
        'userminicourse': 'UserMiniCourse',
        'authtoken': 'AuthToken'
      };
      
      return tableMapping[tableName] || tableName
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
    });
    
    console.log(`   üìã Nalezeno ${dbTableNames.length} tabulek v datab√°zi`);
    console.log(`   üíæ Z√°lohuje se ${backedUpTables.length} tabulek`);
    
    // Najdi tabulky, kter√© se nez√°lohuj√≠
    const missingTables = dbTableNames.filter(table => !backedUpTables.includes(table));
    
    // Najdi tabulky, kter√© se z√°lohuj√≠, ale neexistuj√≠
    const extraTables = backedUpTables.filter(table => !dbTableNames.includes(table));
    
    if (missingTables.length > 0) {
      console.log('\n‚ö†Ô∏è  VAROV√ÅN√ç: Nalezeny tabulky, kter√© se NEZ√ÅLOHUJ√ç:');
      missingTables.forEach(table => {
        console.log(`   ‚ùå ${table}`);
      });
      console.log('\nüîß AKCE POT≈òEBN√Å: Aktualizuj backup script a p≈ôidej z√°lohu tƒõchto tabulek!');
      console.log('   1. P≈ôidej z√°lohu tabulky do funkce backupDatabase()');
      console.log('   2. P≈ôidej tabulku do seznamu backedUpTables v checkBackupCompleteness()');
      console.log('   3. Aktualizuj metadata a rapport');
      console.log('\n‚ùì Chce≈° pokraƒçovat v z√°lohov√°n√≠? (y/n)');
      
      // V produkci by se script zastavil, ale pro v√Ωvoj pokraƒçujeme
      console.log('‚ö†Ô∏è  Pokraƒçujem v z√°lohov√°n√≠, ale ZKONTROLUJ TO!\n');
    }
    
    if (extraTables.length > 0) {
      console.log('\nüí° INFO: Nalezeny tabulky v backup scriptu, kter√© neexistuj√≠ v DB:');
      extraTables.forEach(table => {
        console.log(`   ‚ÑπÔ∏è  ${table} (mo≈æn√° byla smaz√°na)`);
      });
      console.log('');
    }
    
    if (missingTables.length === 0 && extraTables.length === 0) {
      console.log('   ‚úÖ V≈°echny tabulky se spr√°vnƒõ z√°lohuj√≠!\n');
    }
    
    // Detailn√≠ v√Ωpis pro debug
    console.log('   üìä Tabulky v datab√°zi:', dbTableNames.join(', '));
    console.log('   üíæ Z√°lohovan√© tabulky:', backedUpTables.join(', '));
    console.log('');
    
  } catch (error) {
    console.error('‚ùå Chyba p≈ôi kontrole kompletnosti:', error);
    console.log('‚ö†Ô∏è  Pokraƒçujem v z√°lohov√°n√≠ bez kontroly...\n');
  }
}

async function backupDatabase() {
  try {
    console.log('üöÄ Spou≈°t√≠m z√°lohov√°n√≠ datab√°ze...\n');
    
    // 0. KROK: Kontrola kompletnosti z√°lohov√°n√≠
    console.log('üîç 0. Kontroluji kompletnost z√°lohov√°n√≠...');
    await checkBackupCompleteness();
    
    // 1. KROK: Z√°lohov√°n√≠ datab√°ze
    console.log('üìä 1. Z√°lohuji datab√°zi...');
    
    // Urƒçen√≠ c√≠lov√© slo≈æky pro z√°lohy
    const backupDir = path.join(__dirname, '../backups');
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    // Vytvo≈ôen√≠ slo≈æky s ƒçasov√Ωm raz√≠tkem pro tuto z√°lohu
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const currentBackupDir = path.join(backupDir, `backup-${timestamp}`);
    fs.mkdirSync(currentBackupDir);
    
    console.log(`   Z√°lohuji do slo≈æky: ${currentBackupDir}`);
    
    // Z√°loha kurz≈Ø vƒçetnƒõ modul≈Ø, lekc√≠ a materi√°l≈Ø
    const courses = await prisma.course.findMany({
      include: {
        modules: {
          orderBy: { order: 'asc' },
          include: {
            lessons: {
              orderBy: { order: 'asc' },
              include: {
                materials: true
              }
            }
          }
        }
      }
    });
    
    fs.writeFileSync(
      path.join(currentBackupDir, 'courses.json'),
      JSON.stringify(courses, null, 2)
    );
    
    // Z√°loha u≈æivatel≈Ø (bez citliv√Ωch √∫daj≈Ø)
    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true,
        updatedAt: true
      }
    });
    
    fs.writeFileSync(
      path.join(currentBackupDir, 'users.json'),
      JSON.stringify(users, null, 2)
    );
    
    // Z√°loha p≈ô√≠stup≈Ø u≈æivatel≈Ø ke kurz≈Øm
    const userCourses = await prisma.userCourse.findMany();
    fs.writeFileSync(
      path.join(currentBackupDir, 'user-courses.json'),
      JSON.stringify(userCourses, null, 2)
    );
    
    // Z√°loha blog post≈Ø
    const blogPosts = await prisma.blogPost.findMany();
    fs.writeFileSync(
      path.join(currentBackupDir, 'blog-posts.json'),
      JSON.stringify(blogPosts, null, 2)
    );
    
    // Z√°loha auth token≈Ø
    const authTokens = await prisma.authToken.findMany();
    fs.writeFileSync(
      path.join(currentBackupDir, 'auth-tokens.json'),
      JSON.stringify(authTokens, null, 2)
    );
    
    // Z√°loha pokroku u≈æivatel≈Ø v lekc√≠ch
    const userLessonProgress = await prisma.userLessonProgress.findMany();
    fs.writeFileSync(
      path.join(currentBackupDir, 'user-lesson-progress.json'),
      JSON.stringify(userLessonProgress, null, 2)
    );
    
    // Z√°loha n√°kup≈Ø minikurz≈Ø (KRITICK√â!)
    const userMiniCourses = await prisma.userMiniCourse.findMany();
    fs.writeFileSync(
      path.join(currentBackupDir, 'user-mini-courses.json'),
      JSON.stringify(userMiniCourses, null, 2)
    );
    
    // Z√°loha Testtable (pro kompletnost)
    let testtableData = [];
    try {
      testtableData = await prisma.$queryRaw`SELECT * FROM "Testtable"`;
      fs.writeFileSync(
        path.join(currentBackupDir, 'testtable.json'),
        JSON.stringify(testtableData, null, 2)
      );
    } catch (error) {
      // Pokud tabulka neexistuje nebo je pr√°zdn√°, nen√≠ to probl√©m
      console.log('   ‚ÑπÔ∏è  Testtable je pr√°zdn√° nebo neexistuje');
      fs.writeFileSync(
        path.join(currentBackupDir, 'testtable.json'),
        JSON.stringify([], null, 2)
      );
    }
    
    // Vytvo≈ôen√≠ souboru s metadaty z√°lohy
    const metadata = {
      timestamp: new Date().toISOString(),
      stats: {
        courses: courses.length,
        modules: courses.reduce((sum, course) => sum + course.modules.length, 0),
        lessons: courses.reduce((sum, course) => 
          sum + course.modules.reduce((sum, module) => sum + module.lessons.length, 0), 0),
        users: users.length,
        userCourses: userCourses.length,
        blogPosts: blogPosts.length,
        authTokens: authTokens.length,
        userLessonProgress: userLessonProgress.length,
        userMiniCourses: userMiniCourses.length,
        testtable: testtableData.length
      }
    };
    
    fs.writeFileSync(
      path.join(currentBackupDir, 'metadata.json'),
      JSON.stringify(metadata, null, 2)
    );
    
    console.log(`   ‚úÖ Z√°loha dokonƒçena!`);
    console.log(`   üìÅ Data ulo≈æena do: ${currentBackupDir}`);
    console.log(`   üìä Statistiky: ${metadata.stats.courses} kurz≈Ø, ${metadata.stats.modules} modul≈Ø, ${metadata.stats.lessons} lekc√≠, ${metadata.stats.blogPosts} blog post≈Ø, ${metadata.stats.users} u≈æivatel≈Ø, ${metadata.stats.authTokens} token≈Ø, ${metadata.stats.userLessonProgress} pokrok≈Ø, ${metadata.stats.userMiniCourses} n√°kup≈Ø minikurz≈Ø\n`);
    
    // Kontroln√≠ p≈ôehled z√°lohy
    console.log('\n');
    console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.log('‚ïë                           üîç KONTROLN√ç P≈òEHLED Z√ÅLOHY                        ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    
    // Tabulka s p≈ôehledem
    console.log('‚ïë KATEGORIE              ‚îÇ POƒåET    ‚îÇ STATUS        ‚îÇ POZN√ÅMKY               ‚ïë');
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    
    // Blog posty
    const blogStatus = blogPosts.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const blogVideos = blogPosts.filter(p => p.videoUrl).length;
    const blogNote = blogPosts.length > 0 ? `${blogVideos}/${blogPosts.length} s videem` : '≈Ω√°dn√©';
    console.log(`‚ïë üìù Blog posty          ‚îÇ ${blogPosts.length.toString().padEnd(8)} ‚îÇ ${blogStatus.padEnd(13)} ‚îÇ ${blogNote.padEnd(22)} ‚ïë`);
    
    // Kurzy
    const coursesStatus = courses.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const coursesNote = courses.length > 0 ? `${metadata.stats.modules} modul≈Ø` : '≈Ω√°dn√©';
    console.log(`‚ïë üìö Kurzy               ‚îÇ ${courses.length.toString().padEnd(8)} ‚îÇ ${coursesStatus.padEnd(13)} ‚îÇ ${coursesNote.padEnd(22)} ‚ïë`);
    
    // Moduly
    const modulesStatus = metadata.stats.modules > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const modulesNote = metadata.stats.modules > 0 ? 'Vno≈ôen√© v kurzech' : '≈Ω√°dn√©';
    console.log(`‚ïë üóÇÔ∏è  Moduly              ‚îÇ ${metadata.stats.modules.toString().padEnd(8)} ‚îÇ ${modulesStatus.padEnd(13)} ‚îÇ ${modulesNote.padEnd(22)} ‚ïë`);
    
    // Lekce
    const lessonsStatus = metadata.stats.lessons > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const lessonsNote = metadata.stats.lessons > 0 ? 'Vno≈ôen√© v modulech' : '≈Ω√°dn√©';
    console.log(`‚ïë üé• Lekce               ‚îÇ ${metadata.stats.lessons.toString().padEnd(8)} ‚îÇ ${lessonsStatus.padEnd(13)} ‚îÇ ${lessonsNote.padEnd(22)} ‚ïë`);
    
    // Materi√°ly
    const materialsCount = courses.reduce((sum, course) => 
      sum + course.modules.reduce((sum, module) => 
        sum + module.lessons.reduce((sum, lesson) => sum + lesson.materials.length, 0), 0), 0);
    const materialsStatus = materialsCount > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const materialsNote = materialsCount > 0 ? 'Vno≈ôen√© v lekc√≠ch' : '≈Ω√°dn√©';
    console.log(`‚ïë üìé Materi√°ly           ‚îÇ ${materialsCount.toString().padEnd(8)} ‚îÇ ${materialsStatus.padEnd(13)} ‚îÇ ${materialsNote.padEnd(22)} ‚ïë`);
    
    // U≈æivatel√©
    const usersStatus = users.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const adminCount = users.filter(u => u.role === 'ADMIN').length;
    const usersNote = users.length > 0 ? `${adminCount} admin(≈Ø)` : '≈Ω√°dn√≠';
    console.log(`‚ïë üë• U≈æivatel√©           ‚îÇ ${users.length.toString().padEnd(8)} ‚îÇ ${usersStatus.padEnd(13)} ‚îÇ ${usersNote.padEnd(22)} ‚ïë`);
    
    // P≈ô√≠stupy ke kurz≈Øm
    const accessStatus = userCourses.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const accessNote = userCourses.length > 0 ? 'U≈æivatel-kurz p√°ry' : '≈Ω√°dn√©';
    console.log(`‚ïë üîë P≈ô√≠stupy ke kurz≈Øm  ‚îÇ ${userCourses.length.toString().padEnd(8)} ‚îÇ ${accessStatus.padEnd(13)} ‚îÇ ${accessNote.padEnd(22)} ‚ïë`);
    
    // Pokrok v lekc√≠ch
    const progressStatus = userLessonProgress.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const progressNote = userLessonProgress.length > 0 ? 'Dokonƒçen√© lekce' : '≈Ω√°dn√Ω pokrok';
    console.log(`‚ïë üìà Pokrok v lekc√≠ch    ‚îÇ ${userLessonProgress.length.toString().padEnd(8)} ‚îÇ ${progressStatus.padEnd(13)} ‚îÇ ${progressNote.padEnd(22)} ‚ïë`);
    
    // Auth tokeny
    const tokensStatus = authTokens.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const tokensNote = authTokens.length > 0 ? 'Aktivn√≠ tokeny' : '≈Ω√°dn√© tokeny';
    console.log(`‚ïë üîê Auth tokeny         ‚îÇ ${authTokens.length.toString().padEnd(8)} ‚îÇ ${tokensStatus.padEnd(13)} ‚îÇ ${tokensNote.padEnd(22)} ‚ïë`);
    
    // N√°kupy minikurz≈Ø
    const miniCoursesStatus = userMiniCourses.length > 0 ? '‚úÖ Z√ÅLOH√ÅNO' : '‚ùå PR√ÅZDN√â';
    const miniCoursesNote = userMiniCourses.length > 0 ? 'N√°kupy minikurz≈Ø' : '≈Ω√°dn√© n√°kupy';
    console.log(`‚ïë üõí N√°kupy minikurz≈Ø    ‚îÇ ${userMiniCourses.length.toString().padEnd(8)} ‚îÇ ${miniCoursesStatus.padEnd(13)} ‚îÇ ${miniCoursesNote.padEnd(22)} ‚ïë`);
    
    console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
    
    // Celkov√© statistiky
    const totalRecords = blogPosts.length + courses.length + metadata.stats.modules + 
                        metadata.stats.lessons + materialsCount + users.length + 
                        userCourses.length + userLessonProgress.length + authTokens.length + 
                        userMiniCourses.length;
    console.log(`‚ïë üìä CELKEM Z√ÅZNAM≈Æ      ‚îÇ ${totalRecords.toString().padEnd(8)} ‚îÇ ‚úÖ KOMPLETN√ç  ‚îÇ V≈°echna data           ‚ïë`);
    
    console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    
    // Detailn√≠ uk√°zky obsahu
    console.log('\nüìã UK√ÅZKY OBSAHU:');
    console.log('‚îÄ'.repeat(80));
    
    if (blogPosts.length > 0) {
      console.log(`üìù Blog posty (uk√°zka z ${blogPosts.length}):`);
      blogPosts.slice(0, 2).forEach((post, index) => {
        const videoIcon = post.videoUrl ? 'üé•' : 'üìÑ';
        console.log(`   ${videoIcon} ${post.title}`);
      });
      if (blogPosts.length > 2) console.log(`   ... a dal≈°√≠ch ${blogPosts.length - 2}`);
    }
    
    if (courses.length > 0) {
      console.log(`\nüìö Kurzy (uk√°zka z ${courses.length}):`);
      courses.slice(0, 2).forEach((course, index) => {
        console.log(`   üìñ ${course.title} (${course.modules.length}M/${course.modules.reduce((s,m) => s + m.lessons.length, 0)}L)`);
      });
      if (courses.length > 2) console.log(`   ... a dal≈°√≠ch ${courses.length - 2}`);
    }
    
    if (users.length > 0) {
      console.log(`\nüë• U≈æivatel√©:`);
      users.forEach(user => {
        const icon = user.role === 'ADMIN' ? 'üëë' : 'üë§';
        console.log(`   ${icon} ${user.email} (${user.role})`);
      });
    }
    
    // N√°kupy minikurz≈Ø
    if (userMiniCourses.length > 0) {
      console.log(`\nüõí N√°kupy minikurz≈Ø (${userMiniCourses.length}):`);
      userMiniCourses.forEach(purchase => {
        const user = users.find(u => u.id === purchase.userId);
        const blogPost = blogPosts.find(bp => bp.id === purchase.blogPostId);
        if (user && blogPost) {
          console.log(`   üí∞ ${user.email} ‚Üí ${blogPost.title} (${purchase.price} Kƒç)`);
        }
      });
    } else {
      console.log(`\nüõí N√°kupy minikurz≈Ø: ≈Ω√°dn√© n√°kupy`);
    }
    
    // Pokrok u≈æivatel≈Ø
    if (userLessonProgress.length > 0) {
      console.log(`\nüìà Pokrok v lekc√≠ch (${userLessonProgress.length}):`);
      userLessonProgress.slice(0, 3).forEach(progress => {
        const user = users.find(u => u.id === progress.userId);
        console.log(`   ‚úÖ ${user?.email || 'Nezn√°m√Ω'} - dokonƒçeno: ${progress.completed ? 'ANO' : 'NE'}`);
      });
      if (userLessonProgress.length > 3) {
        console.log(`   ... a dal≈°√≠ch ${userLessonProgress.length - 3}`);
      }
    } else {
      console.log(`\nüìà Pokrok v lekc√≠ch: ≈Ω√°dn√Ω pokrok zat√≠m`);
    }
    
    // Auth tokeny
    if (authTokens.length > 0) {
      console.log(`\nüîê Auth tokeny (${authTokens.length}):`);
      authTokens.slice(0, 2).forEach(token => {
        const user = users.find(u => u.id === token.userId);
        console.log(`   üîë ${user?.email || 'Nezn√°m√Ω'} - vypr≈°√≠: ${new Date(token.expires).toLocaleDateString('cs-CZ')}`);
      });
      if (authTokens.length > 2) {
        console.log(`   ... a dal≈°√≠ch ${authTokens.length - 2}`);
      }
    } else {
      console.log(`\nüîê Auth tokeny: ≈Ω√°dn√© aktivn√≠ tokeny`);
    }
    
    // Materi√°ly
    if (materialsCount > 0) {
      console.log(`\nüìé Materi√°ly (${materialsCount}):`);
      let shownMaterials = 0;
      courses.forEach(course => {
        course.modules.forEach(module => {
          module.lessons.forEach(lesson => {
            if (lesson.materials && lesson.materials.length > 0 && shownMaterials < 3) {
              lesson.materials.forEach(material => {
                if (shownMaterials < 3) {
                  console.log(`   üìÑ ${material.title} (${lesson.title})`);
                  shownMaterials++;
                }
              });
            }
          });
        });
      });
      if (materialsCount > 3) {
        console.log(`   ... a dal≈°√≠ch ${materialsCount - 3}`);
      }
    } else {
      console.log(`\nüìé Materi√°ly: ≈Ω√°dn√© materi√°ly`);
    }
    
    // Cenov√© informace
    const totalCourseValue = courses.reduce((sum, course) => sum + (course.price || 0), 0);
    const totalMiniCourseValue = blogPosts.reduce((sum, post) => sum + (post.price || 0), 0);
    const totalPurchaseValue = userMiniCourses.reduce((sum, purchase) => sum + (purchase.price || 0), 0);
    
    console.log(`\nüí∞ Cenov√© informace:`);
    console.log(`   üìö Celkov√° hodnota kurz≈Ø: ${totalCourseValue} Kƒç`);
    console.log(`   üìù Celkov√° hodnota minikurz≈Ø: ${totalMiniCourseValue} Kƒç`);
    console.log(`   üõí Celkov√° hodnota n√°kup≈Ø: ${totalPurchaseValue} Kƒç`);
    
    console.log('‚îÄ'.repeat(80));
    
    // 2. KROK: Pokroƒçil√° kontrola integrity z√°lohy
    console.log('\nüîç 2. Kontroluji integritu z√°lohy...');
    await performBackupIntegrityCheck(currentBackupDir, {
      courses,
      users,
      userCourses,
      blogPosts,
      authTokens,
      userLessonProgress,
      userMiniCourses,
      testtableData
    });
    
    console.log('‚úÖ Z√°loha dokonƒçena!');
    console.log('\nüìã Pro nahr√°n√≠ na GitHub pou≈æij:');
    console.log('   git add .');
    console.log('   git commit -m "Z√°loha datab√°ze"');
    console.log('   git push origin main');
    console.log('\nüí° Nebo pou≈æij: git add . && git commit -m "Z√°loha datab√°ze" && git push origin main');
    
  } catch (error) {
    console.error('‚ùå Chyba p≈ôi z√°lohov√°n√≠:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

// Spu≈°tƒõn√≠ skriptu
backupDatabase();
